# 第 1 章: 权衡的艺术

“框架设计里到处都是权衡的艺术。”

## 框架设计的选择与权衡
框架设计的选择与权衡：
- 范式角度：命令式/声明式
    - 命令式框架：关注做事的过程，比如Jquery
    - 声明式框架：关注结果，而实现结果的过程，由框架内部包裹的“命令式逻辑”完成，比如 Vue
- 编译运行角度：纯运行时/纯编译时/运行时+编译时
    - 纯运行时：没有编译过程，性能较差，比如纯 Render 函数执行一段生成 Dom 的 js，不能将 HTML 编译成 JS。
    - 纯编译时：不需要任何运行，直接编译成可执行的 JS 代码，性能理论上最好，但有损灵活性，比如 Svelte
    - 运行时+编译时：编译时将 HTML 转换成 JS，同时对编译产物进行分析优化，方便运行时运行，比如 Vue

## 命令式与声明式


|  框架  | 命令式 | 声明式 |
| ----------- | ----------- | ----------- |
| 性能      | 性能最优      | 性能永远不优于命令式   |
| 性能消耗     | 直接修改的性能消耗      | 找出差异的性能消耗+直接修改的性性能消耗   |
| 可维护性   | 可维护性差，需要关注整个过程        | 可维护性高，仅需要关注结果        |

**框架设计就是在性能和可维护性之间的权衡：在保持可维护性的同时让性能损失最小化**

### Vue 声明式框架中的性能优化：以 Dom 操作为例

首先需要明确一个结论：涉及 Dom 的计算要远比 JavaScript 层面的性能差的多，不在一个数量级

|  方式  |  | innerHTML | 虚拟 Dom | 原生 JavaScript（document.createElement) |
| ----------- | ----------- | ----------- | ----------- | ----------- |
| 创建页面 | JS层面 | 拼接 HTML 字符串  | 创建 JS 对象（Vnode） |  |
|        | Dom层面 | 新建所有 Dom 元素 | 新建所有 Dom 元素 | 新建所有 Dom 元素 |
| 更新页面 | JS层面 | 拼接 HTML 字符串  | 创建 JS 对象（Vnode）+ diff |  |
|        | Dom层面 | 销毁所有 Dom 元素 + 新建所有 Dom 元素 | 必要的 Dom 更新 | 必要的 Dom 更新 |
| 总结 | 性能 | 性能最差 | 性能次优 | 性能最优 |
|  | 可维护性 | 可维护性较差 | 可维护性强 | 可维护性最差 |
|  | 心智负担 | 心智负担较差 | 声明式心智负担小 | 心智负担极大 |
